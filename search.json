[{"title":"核工高清素材图(长期更新中)","url":"/Mrluo123.http-github.io/post/1b933ad6.html","content":"\n\n\n{% asset_img reactor.gif 800 800 石墨慢化反应堆示意图%}\n\n\n\n{% asset_img 87b4-hwzkfpu2822108.jpg 800 800 大亚湾核电站%}\n\n#### **注：更多核电主题图片来源网站：**\n\n- [视觉中国](https://www.vcg.com/creative-image/hedianzhan/)\n- [全景图库](https://www.quanjing.com/category/12702301.html)\n- 千图网\n\n","tags":["素材"],"categories":["素材"]},{"title":"稀疏矩阵存储压缩技术简单介绍","url":"/Mrluo123.http-github.io/post/9ed8a6a7.html","content":"\n## 什么是稀疏矩阵？为何要压缩？\n\n在科学计算中，经常面临大量的线性稀疏矩阵方程组求解。所谓稀疏矩阵，即元素大部分是0的矩阵(有些资料定义非零元素不超过5%的矩阵，为稀疏矩阵，如下图所示为稀疏矩阵和稠密矩阵的示意图), 矩阵的稀疏性可以用一个分数来量化，即矩阵中零元素的个数除以矩阵中元素的总数。\n\n{% asset_img sparse_dense.gif 600 600 %}\n\n显然，对稀疏矩阵中的非零项进行存储对计算机内存是极大的浪费，因为这些非零项的信息对求解毫无意义，因此在实际操作中往往采用矩阵存储压缩技术，存储稀疏矩阵时常用的有如下三种压缩格式:\n\n## Coordinate(COO)/三元组\n\n{% asset_img coo.gif 600 600 %}\n\n这种存储格式比较简单易懂，每一个元素需要用一个三元组来表示，分别是（行号，列号，数值），对应上图右边的一列。这种方式简单，但是记录单信息多（行列），每个三元组自己可以定位，因此空间不是最优的。\n\n常用的开源矩阵求解库Eigen中的[Triplet](https://eigen.tuxfamily.org/dox/classEigen_1_1Triplet.html)就对应这一操作。\n\n\n\n## Compressed Sparse Row (CSR)/行优先\n\n{% asset_img csr.gif 600 600 %}\n\n这是经常用的一种，我们会经常在一些标准的线性代数库或者数值运算库中看到此方式存储；CSR是比较标准的一种，也需要三类数据来表达：数值，列号，以及行偏移。CSR不是三元组，而是整体的编码方式。数值和列号与COO一致，表示一个元素以及其列号，行偏移表示某一行的第一个元素在values里面的起始偏移位置。\n\n\n\n### Compressed Sparse Column (CSC)/列优先\n\n{% asset_img csc.gif 600 600 %}\n\nCSR是按行来存储一个稀疏矩阵的，其原理与CSC类似。indptr中的数据表示矩阵中每一行的数据在data中开始和结束的索引，而indices中的数据表示所对应的在data中的数据在矩阵中其所在行的所在列数。可以看出，在indptr、indices和data三个数组相同的情况下，通过CSC和CSR分别表示出来的矩阵互为转置关系。\n\n\n\n注：上述图片来自[Matt Eding](https://matteding.github.io/)的个人博客，更多矩阵压缩方法可参考[Matt Eding's Blog](https://matteding.github.io/2019/04/25/sparse-matrices/)或[CUDA手册](https://docs.nvidia.com/cuda/pdf/CUSPARSE_Library.pdf)。\n\n","tags":["CUDA","稀疏矩阵","计算机"],"categories":["科学计算"]},{"title":"CUDA-ubuntu20安装教程","url":"/Mrluo123.http-github.io/post/199927a1.html","content":"\n## 0. CUDA简介\n> CUDA（Compute Unified Device Architecture，统一计算架构）是由英伟达NVIDIA所推出的一种集成技术，是该公司对于GPGPU的正式名称。透过这个技术，用户可利用NVIDIA的GPU进行图像处理之外的运算，亦是首次可以利用GPU作为C-编译器的开发环境。CUDA 开发包（CUDA Toolkit ）只能将自家的CUDA C-语言，也就是执行于GPU的部分编译成PTX中间语言或是特定NVIDIA GPU架构的机器代码（NVIDIA 官方称为 \"device code\"）；而执行于中央处理器部分的C / C++代码（NVIDIA 官方称为 \"host code\"）仍依赖于外部的编译器，如Microsoft Windows下需要Microsoft Visual Studio；Linux下则主要依赖于GCC。\n\n> 在GPUs（GPGPU）上使用图形APIs进行传统通用计算，CUDA技术有下列几个优点：\n> - 分散读取——代码可以从存储器的任意地址读取\n> - 统一虚拟内存（Unified Memory, 从 CUDA 6.0 开始）—— 将所有 CPU 和 GPU 的内存置于统一管理的虚拟内存空间下。\n> - 共享存储器（Global Memory）—— 访问快速的区域，使之在多个线程间共享，有效带宽比纹理存储器（Texture Memory）更大。\n> - 与GPU之间更快的下载与回读\n> - 全面支持整型与位操作，包括整型纹理查找\n\n## 1. 安装步骤\n1. Add GPG Key on Ubuntu 20.04\n```shell\nsudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/3bf863cc.pub\n```\n2. Add CUDA Toolkit Repository\n```shell\nwget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin\nsudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600\n#Add the repository\nsudo add-apt-repository \"deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/ /\"\n```\n3. Run APT Update\n```shell\nsudo apt-get update\n```\n4. Install Nvidia CUDA on Ubuntu 20.04\n```shell\nsudo apt install cuda\n#Add the CUDA installed folder in your system path\necho 'export PATH=/usr/local/cuda/bin${PATH:+:${PATH}}' >> ~/.bashrc\nsource ~/.bashrc\n#check the version\nnvcc --version\n```\n## 2. 运行你的第一个CUDA程序-HelloWorld\n1. Here is the sample of CUDA C code to create your first program:\n```shell\ngedit helloworld.cu\n```\n2. Paste the following code in the file:\n\n```C++\n#include <stdio.h>\n__global__\nvoid saxpy(int n, float a, float *x, float *y)\n{\nint i = blockIdx.x*blockDim.x + threadIdx.x;\nif (i < n) y[i] = a*x[i] + y[i];\n}\nint main(void)\n{\nint N = 1<<20;\nfloat *x, *y, *d_x, *d_y;\nx = (float*)malloc(N*sizeof(float));\ny = (float*)malloc(N*sizeof(float));\ncudaMalloc(&d_x, N*sizeof(float));\ncudaMalloc(&d_y, N*sizeof(float));\nfor (int i = 0; i < N; i++) {\nx[i] = 1.0f;\ny[i] = 2.0f;\n}\ncudaMemcpy(d_x, x, N*sizeof(float), cudaMemcpyHostToDevice);\ncudaMemcpy(d_y, y, N*sizeof(float), cudaMemcpyHostToDevice);\n// Perform SAXPY on 1M elements\nsaxpy<<<(N+255)/256, 256>>>(N, 2.0f, d_x, d_y);\ncudaMemcpy(y, d_y, N*sizeof(float), cudaMemcpyDeviceToHost);\nfloat maxError = 0.0f;\nfor (int i = 0; i < N; i++)\nmaxError = max(maxError, abs(y[i]-4.0f));\nprintf(\"Max error: %f\\n\", maxError);\ncudaFree(d_x);\ncudaFree(d_y);\nfree(x);\nfree(y);\n}\n```\n\n3. Compile your program\n```shell\nnvcc -o mycuda helloworld.cu\n```\n\n4. Run your CUDA program\n```shell\n./mycuda\n```\n{% asset_img 1.png %}\n\n## 3. 更多教程\n - NVIDIA CUDA C++ Programming Guide：\n - https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html\n - CUDA C++ Best Practices Guide：\n - https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html\n - CUDA编程入门极简教程：\n - https://zhuanlan.zhihu.com/p/34587739\n - CUDA学习资料-博主推荐：\n - https://www.cnblogs.com/5long/p/cuda-learning.html\n - ...","tags":["Linux","CUDA","GPU"],"categories":["高性能计算"]},{"title":"数字孪生技术学习","url":"/Mrluo123.http-github.io/post/d2feeb9b.html","content":"\n\n\n\n\n<embed src=\"../pdf/White-paper-for-DT.pdf\" width=\"100%\" height = \"750\" type=\"application/pdf\">\n","tags":["数字孪生"],"categories":["数字孪生"]},{"title":"超算作业提交：Slurm命令备忘录","url":"/Mrluo123.http-github.io/post/65958fd8.html","content":"\n## 0.常用术语\n\nuser：用户名\nnode：计算节点\ncore：cpu 核\njob：作业\njob step：作业步，单个作业可以有多个作业步\npartition：分区，作业需在特定分区中运行\nQOS：服务质量，可理解为用户可使用的 CPU、内存等资源限制\ntasks：任务数，默认一个任务使用一个 cpu 核，可理解为作业所需的 cpu 核数\nsocket：cpu 插槽，可理解为物理 cpu 颗数\nstdout：标准输出文件，程序运行正常时输出信息的文件，一般指输出到屏幕的信息\nstderr：标准错误文件，程序运行出错时输出信息的文件，一般指输出到屏幕的信息\n\n## **1 Slurm作业管理系统**\n\n大多数[计算机集群](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4)（Cluster）系统都使用Slurm作业管理系统，采用共享模式。为避免系统资源浪费，使用时请尽量保证满核提交（即为单节点核数的整数倍），**禁止在登录节点直接运行计算程序**。作业管理系统常用命令如下：\n\n## **2 sinfo查看系统资源**\n\nsinfo得到的结果是当前账号可使用的队列资源信息，如下所示：\n{% asset_img 1.png %}\n\n> 第一列PARTITION是队列名。\n> 第二列AVAIL是队列可用情况，如果显示up则是可用状态；如果是inact则是不可用状态。\n> 第三列TIMELIMIT是作业运行时间限制，默认是infinite没有限制。\n> 第四列NODES是节点数。\n> 第五列STATE是节点状态，idle是空闲节点，alloc是已被占用节点，comp是正在释放资源的节点，其他状态的节点都不可用。\n> 第六列NODELIST是节点列表。\n\nsinfo的常用命令选项：\n\n> sinfo -n comput1\n> 指定显示节点comput1的使用情况\n> sinfo -p com\n> 指定显示队列com情况\n\n其他选项可以通过sinfo --help查询\n\n## **3 squeue查看作业状态**\n\nsqueue得到的结果是当前账号的作业运行状态，如果squeue没有作业信息，说明作业已退出。\n\n{% asset_img 2.png %}\n\n> 第一列JOBID是作业号，作业号是唯一的。\n> 第二列PARTITION是作业运行使用的队列名。\n> 第三列NAME是作业名。\n> 第四列USER是超算账号名。\n> 第五列ST是作业状态，R表示正常运行，PD表示在排队，CG表示正在退出，S是管理员暂时挂起。\n> 第六列TIME是作业运行时间。\n> 第七列NODES是作业使用的节点数。\n> 第八列NODELIST(REASON)\n> 对于运行作业（R状态）显示作业使用的节点列表；对于排队作业（PD状态），显示排队的原因。\n\nsqueue的 常用命令选项：\n\n> queue -j 123456\n> 查看作业号为123456的作业信息\n> squeue -u paratera\n> 查看超算账号为 paratera的作业信息\n> squeue –p com\n> 查看提交到com队列的作业信息\n> squeue -w comput1\n> 查看使用到comput1节点的作业信息\n\n其他选项可通过squeue --help命令查看。\n\n## **4 srun交互式提交作业**\n\nsrun [options] program命令属于交互式提交作业，有屏幕输出，但容易受网络波动影响，断网或关闭窗口会导致作业中断。\nsrun 命令示例：\n\n> srun -p com -w comput[1-2] -N 2 -n 40 -t 20 A.exe\n\n交互式提交A.exe程序。如果不关心节点和时间限制，可简写为srun -N 2 -n 40 A.exe\n\n> -p com指定提交作业到com队列；\n> -w comput[1-2] 指定使用节点comput[1-2]；\n> -N 2 指定使用2个节点；\n> -n 40 指定进程数为40；\n> -t 20 指定作业运行时间限制为20分钟。\n\nsrun 的一些常用命令选项：\n\n> -N 3\n> 指定节点数为3\n> -n 20\n> 指定进程数为20\n> -c 20\n> 指定每个进程（任务）使用的CPU核为20\n> -p com\n> 指定提交作业到com 队列\n> -w comput[1-2]\n> 指定提交作业到comput1、comput2节点\n> -x comput[1-2]\n> 排除comput1、comput2节点\n> -o out.log\n> 指定标准输出到out.log文件\n> -e err.log\n> 指定重定向错误输出到err.log文件\n> -J JOBNAME\n> 指定作业名为JOBNAME\n> -t 20\n> 限制运行20分钟\n\nsrun的其他选项可通过srun --help查看。\n\n## **5 sbatch后台提交作业**\n\nsbatch一般情况下与srun一起提交作业到后台，需要将srun写到脚本中，再用sbatch 提交脚本。这种方式不受本地网络波动影响，提交作业后可以关闭本地电脑。sbatch命令没有屏幕输出，默认输出日志为提交目录下的slurm-xxx.out文件，可以使用tail -f slurm-xxx.out实时查看日志，其中xxx为作业号。\nsbatch命令示例1（40个进程提交A.exe程序）：\n编写脚本job1.sh，内容如下：\n\n> \\#!/bin/bash\n> srun -n 40 A.exe\n\n然后在命令行执行sbatch -p com job1.sh 提交作业。脚本中的#!/bin/bash是bash脚本的固定格式。从脚本的形式可以看出，提交脚本是一个shell脚本，因此常用的shell脚本语法都可以使用。作业开始运行后，在提交目录会生成一个slurm-xxx.out日志文件，其中xxx表示作业号。\nsbatch命令示例2（指定2个节点，4个进程，每个进程10个cpu核提交A.exe程序，限制运行60分钟）：\n编写脚本job2.sh，内容如下：\n\n> \\#!/bin/bash\n> \\#SBATCH -N 2\n> \\#SBATCH -n 4\n> \\#SBATCH -c 20\n> \\#SBATCH -t 60\n> srun -n 4 A.exe\n\n然后在命令行执行sbatch -p com job2.sh就可以提交作业。其中#SBATCH注释行是slurm定义的作业执行方式说明，一些需要通过命令行指定的设置可以通过这些说明写在脚本里，避免了每次提交作业写很长的命令行。\nsbatch命令示例3（单节点提交多任务）\n编写脚本job3.sh，内容如下：\n\n> \\#!/bin/bash\n> srun -n 5 A.exe undefined\n> srun -n 5 B.exe undefined\n> srun -n 5 C.exe undefined\n> srun -n 5 C.exe undefined\n> wait\n\n然后在命令行执行sbatch -N 1 -p com job3.sh，这里是单节点同时提交4个任务，每个任务使用5个进程。这里需要5个任务全部执行完毕，作业才会退出。\nsbatch 的一些常用命令选项基本与srun的相同，具体可以通过sbatch --help查看。\n\n## **6 salloc分配模式作业提交**\n\nsalloc命令用于申请节点资源，一般用法如下：\n\n> 1、执行salloc -p com；\n> 2、执行squeue 查看分配到的节点资源，比如分配到n001；\n> 3、执行ssh comput1登陆到所分配的节点；\n> 4、登陆节点后可以执行需要的提交命令或程序；\n> 5、作业结束后，执行scancel JOBID释放分配模式作业的节点资源。\n\n## **7 scancel取消已提交的作业**\n\nscancel 可以取消正在运行或排队的作业。\nscancel的一些常用命令示例：\n\n> scancel 123456\n> 取消作业号为123456的作业\n> scancel -n test\n> 取消作业名为test的作业\n> scancel -p com\n> 取消提交到com队列的作业\n> scancel -t PENDING\n> 取消正在排队的作业\n> scancel -w comput1\n> 取消运行在comput1节点上的作业\n\nscancel的其他参数选项，可通过scancel --help查看\n\n## **8 scontrol查看正在运行的作业信息**\n\nscontrol命令可以查看正在运行的作业详情，比如提交目录、提交脚本、使用核数情况等，对已退出的作业无效。\nscontrol的常用示例：\n\n> scontrol show job 123456\n\n查看作业号为123456的作业详情。\nscontrol 的其他参数选项，可通过scontrol --help查看。\n\n## **9 sacct查看历史作业信息**\n\nsacct命令可以查看历史作业的起止时间、结束状态、作业号、作业名、使用的节点数、节点列表、运行时间等。\nsacct的常用命令示例：\n\n> sacct -u paratera -S 2018-07-01 -E now --field=jobid,partition,jobname,user,nnodes,nodelist,start,end,elapsed,state\n\n其中，-u paratera是指查看paratera账号的历史作业，-S是开始查询时间，-E是截止查询时间，--format定义了输出的格式，jobid是指作业号，partition是指提交队列，user是指超算账号名，nnodes是节点数，nodelist是节点列表，start是开始运行时间，end是作业退出时间，elapsed是运行时间，state是作业结束状态。sacct --helpformat可以查看支持的输出格式。\nsacct的其他参数选项可通过sacct --help查看。\n\n## **10 作业模版**\n\n\n\n> \\#!/bin/bash\n> \\#SBATCH -p com 指定队列名称\n> \\#SBATCH -J test 指定作业名称\n> \\#SBATCH -N 2 指定要提交的节点数量\n> \\#SBATCH -n 8 指定要提交的总核数\n> \\#SBATCH -o test.o 指定标准输出文件名\n> \\#SBATCH -e test.e 指定错误输出文件名\n> srun -N 2 -n 8 -p com hostname 程序运行命令\n\n\n\n## **11 Linux 常用命令**\n\n\n\n1. date :显示或设置系统时间 \n2. ls :列出当前或指定目录下的文件或目录。 \n3. pwd: 显示当前目录 \n4. cd : 进入指定目录 \n5. more, less, head tail: 显示或部分显示文件内容. \n6. lp/lpstat/cancel, lpr/lpq/lprm: 打印文件的有关命令.\n7. chmod:更改文件读、写或执行权限 \n8. rm :删除文件或目录 \n9. cp:拷贝文件或目录\n10. mv : 文件更名或移动\n11. vi/vim:文本编辑器 \n12. top : 查看系统长时间运行的主要进程 \n13. fg jobid :可以将一个后台进程放到前台。\n    Ctrl-z 可以将前台进程挂起(suspend), 然后可以用 bg jobid 让其到后台运行。\n    job undefined 可以直接让 job 直接在后台运行。 \n14. ps:查看系统进程, ps -e 或 ps -o pid,ppid,session,tpgid, comm (其中 session 显示的 sessionid, tpgid 显示前台进程组 id, comm 显示命令名称。)\n15. kill : 杀掉一个指定进程号的进程或向系统发送一个信号。\n16. scp: 远程文件拷贝。 \n17. man :给出指定命令的详细使用说明。 \n18. Linux 的绝大部分命令都可以用man命令来查看更详细的说明。\n\n\n\n## **12 其他教程**\n\n官方手册（英文）：https://slurm.schedmd.com/documentation.html\n\n官方手册（中文）：https://docs.slurm.cn/users/kuai-su-ru-men-yong-hu-zhi-nan\n\nSlurm作业调度系统指南（[中科大超算中心](https://scc.ustc.edu.cn/)）：http://hmli.ustc.edu.cn/doc/userguide/slurm-userguide.pdf\n\n\n\n## 附录：Slurm Cheat Sheet\n\n<embed src=\"../pdf/slurm_summary.pdf\" width=\"100%\" height = \"750\" type=\"application/pdf\">\n","tags":["集群作业"],"categories":["并行计算"]},{"title":"KMC平台基础软件配置方法一览","url":"/Mrluo123.http-github.io/post/63333.html","content":"\n\n本文为多物理多尺度耦合平台KMC的基础软件配置教程。\n<!-- more -->\n\n\n## **1. gcc&g++&gfortran 4.8.5**\n\n\n- ubuntu20以后版本需要添加gcc-4的源，否则apt库找不到gcc-4.8：\n\n```shell\ncd /etc/apt or \nsudo vim /etc/apt/sources.list\n#append this to sources.list:\ndeb http://dk.archive.ubuntu.com/ubuntu/ xenial main\ndeb http://dk.archive.ubuntu.com/ubuntu/ xenial universe\n#then\nsudo apt update\nsudo apt-get install gcc-4.9\n```\n\n- 安装gcc/g++ 4.8/gfortran，在terminal依次执行如下命令：\n\n```shell\nsudo apt-get install gcc-4.8\nsudo apt-get install g++-4.8\nsudo apt-get install gfortran-4.8\n```\n\n- 链接gcc/g++/gfortran实现降级，在terminal依次执行如下命令：\n\n```shell\ncd /usr/bin\nsudo rm -rf gcc&&sudo ln -s gcc-4.8 gcc\nsudo rm -rf g++&&sudo ln -s g++-4.8 g++\ncd /usr/bin&&sudo rm -rf gfortran&&sudo ln -s gfortran-4.8 gfortran\n```\n\n\n\n## 2. cmake-3.9.2\n\n> CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。\n>\n> cmake 的特点主要有：\n>\n> - 开放源代码，使用类 BSD 许可发布。http://cmake.org/HTML/Copyright.html\n> - 跨平台，并可生成 native 编译配置文件，在 Linux/Unix 平台，生成 makefile，在苹果平台，可以生成 xcode，在 Windows 平台，可以生成 MSVC 的工程文件。\n> - 能够管理大型项目，KDE4 就是最好的证明。\n> - 简化编译构建过程和编译过程。Cmake 的工具链非常简单：cmake+make。\n> - 高效虑，按照 KDE 官方说法，CMake 构建 KDE4 的 kdelibs 要比使用 autotools 来构建 KDE3.5.6 的 kdelibs 快 40%，主要是因为 Cmake 在工具链中没有 libtool\n> - 可扩展，可以为 cmake 编写特定功能的模块，扩充 cmake 功能。\n>\n> 在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：\n>\n> 1. 编写 CMake 配置文件 CMakeLists.txt 。\n> 2. 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile。其中， PATH 是 CMakeLists.txt 所在的目录。\n> 3. 使用 make 命令进行编译。\n\n```shell\n#在terminal依次执行如下命令：\nsudo apt-get install build-essential\n#http://www.cmake.org/files  这个网站里面有cmake的所有版本的列表，下载对应的cmake版本\nwget http://www.cmake.org/files/v3.9/cmake-3.9.2.tar.gz\ntar xf cmake-3.9.2.tar.gz\ncd cmake-3.9.2\n./configure\nmake\nsudo make install\n```\n\n\n\n## 3. OpenFOAM\n\nOpenFOAM and *ParaView* can be simply installed for the first time using the `apt` package management tool. \n\nJust Follow this website in openfoam.org:\n\nhttps://openfoam.org/download/9-ubuntu/\n\n\n\n## 4. Solaris Studio12.6\n\n> Oracle Solaris Studio 由两套工具组成：编译器套件和分析套件。每个套件中所包含的工具都设计为相互配合使用，为单线程、多线程和分布式应用程序的开发提供优化的开发环境。\n>\n> 开发在 SPARC 或 x86 和 x64 平台上的 Oracle Solaris 10 或 Oracle Solaris 11 中运行的 C、C++ 和 Fortran 应用程序时，或者开发在 x86 和 x64 平台上的 Oracle Linux 中运行的 C、C++ 和 Fortran 应用程序时，Oracle Solaris Studio 可提供所需的任何内容。编译器和分析工具的设计使您的应用程序能在 Oracle Sun 系统中以最理想的状态运行。\n>\n> 具体地说，Oracle Solaris Studio 编译器和分析工具在设计上可利用较新的 CPU（包括 SPARC T5、SPARC M5、SPARC M6、SPARC M10、SPARC M10+ 以及 Intel Ivy Bridge 和 Haswell 处理器）的功能，也可利用较旧的 SPARC T4、SPARC T3 以及 Intel® Xeon® 和 AMD Opteron 处理器的功能。利用 Oracle Solaris Studio 可以更轻松地创建适用于这些平台的并行和并发软件应用程序\n>\n> KMC平台使用Solaris主要为了利用其内置的f77编译器编译R5。\n\n1. 在官网下最新版，[[sunstudio12.6]](https://www.oracle.com/tools/developerstudio/downloads/developer-studio-jsp.html)，注意区分普通linux版本（基于deb)和redhat版本（基于rpm)。\n\n2. 安装java.下载[jdk-8u261-linux-x64.tar.gz](https://www.oracle.com/in/java/technologies/javase/javase-jdk8-downloads.html)，在terminal依次执行如下命令：\n\n   ```shell\n   sudo mkdir /usr/java\n   tar -zxvf /home/username/jdk-8u261-linux-x64.tar.gz -C /usr/java/\n   vim /etc/profile\n   ```\n\n   \n\n3. 更新java环境变量，在bashrc中添加如下内容，并更新bashrc配置：`source /etc/profile`\n\n   ```shell\n   export JAVA_HOME=/usr/java/jdk1.8.0_261\n   export JRE_HOME=${JAVA_HOME}/jre\n   export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH\n   export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin\n   export PATH=${JAVA_PATH}:$PATH\n   ```\n\n   \n\n4. 查看java版本，在terminal执行命令：`java -version`,显示java version 1.8.0_261则表示java安装和配置成功，这是下一步必备条件。\n\n5. 安装SolarisStudio12.6，在terminal依次执行如下命令：\n\n   如果是rpm包：\n\n   ```shell\n   tar -jxvf OracleDeveloperStudio12.6-linux-x86-rpm.tar.bz2\n   cd OracleDeveloperStudio12.6-linux-x86-rpm/\n   sudo ./developerstudio.sh\n   ```\n\n   如果是deb包，解压studio12.6压缩包后，配置环境变量即可：\n\n   ```shell\n   export PATH=$PATH:your_file_path/developerstudio12.6/bin\n   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:your_file_path/developerstudio12.6/lib\n   ```\n\n   \n\n## 5. Trio_U\n\nComing soon...\n\n\n\n## 6. SALOME\n\n参见本站文章：[`虚拟机安装Debian以及配置SALOME教程`](https://mrluo123.github.io/Mrluo123.http-github.io/2021/12/07/xu-ni-ji-an-zhuang-debian-yi-ji-pei-zhi-salome-jiao-cheng/)\n\n\n\n## 7. Aptplot & SNAP\n\n- **什么是SNAP？有哪些用处？**\n\n  - The Symbolic Nuclear Analysis Package (SNAP) 包含一套工具包，旨在简化核工程计算分析的流程，方便用户建模，计算以及结果的后处理等。目前支持RELAP、TARCE、COBRA等程序,可用于可视化建模、自动提交、监控作业等功能。\n\n  - SNAP 建立在工程分析通用应用程序框架 (CAFEAN) 之上，该框架提供了一个高度灵活的框架，用于创建和编辑工程分析代码的输入，以及用于提交、监控和与代码交互的广泛功能。\n\n- **什么是Applot?有哪些用处？**\n  - AptPlot 是一款免费的 WYSIWYG 2D 绘图工具，旨在创建数字数据的生产质量图和执行数据分析。 AptPlot 包含广泛的脚本和 GUI 支持，可用于程序的结果后处理，比如读取RELAP和TRACE输出的二进制结果，并绘制参数随时间变化的折线图、提取某一变量的数据，等。\n\n- **如何获取Aptplot和SNAP？**\n  - 注册登录网站：https://www.aptplot.com\n  - 提交软件使用申请，需美国NRC审批通过才能获得。\n  \n- **如何安装Aptplot和SNAP？**\n\n  - 这两者的安装方法类似，在获取到安装包后，首先需要确保java安装完毕，前面提到的jdk-8u261即可满足条件。\n\n\n  - 执行命令：`java -jar xxx.jar  ` #xxx表示SNAP或Aptplot的安装包\n\n\n  - 然后按照提示一步一步操作即可。\n\n\n\n\n## 8. MPICH\n\n> MPICH是MPI标准的一种最重要的实现，可以免费从网上下载。MPICH的开发与MPI规范的制订是同步进行的，因此MPICH最能反映MPI的变化和发展。\n\nMPICH的安装教程参见本站文章：[在Windows和Linux下如何配置MPI](https://mrluo123.github.io/Mrluo123.http-github.io/post/21781.html)\n\n","tags":["Linux","SALOME","多尺度多物理耦合"],"categories":["数值反应堆"]},{"title":"在Windows和Linux下如何配置MPI","url":"/Mrluo123.http-github.io/post/21781.html","content":"\n# 在Windows和Linux下如何配置MPI\n\n> MPI（英语：Message Passing Interface，缩写MPI）是一个跨语言的通讯协议，用于编写并行计算机。支持点对点和广播。MPI是一个信息传递应用程序接口，包括协议和和语义说明，他们指明其如何在各种实现中发挥其特性。**MPI****的目标是高性能，大规模性，和可移植性。当下MPI****仍为高性能计算的主要模型**。\n>\n> 在WIndows下和Linux下配置MPI的方法有所不同，本文将详细讲述如何在这两个操作系统下安装MPI并配置和运行一个简单的C++实例。\n>\n<!-- more -->\n## Windows\n\n*以下实例为WIN11+Visual Studio 2022*\n\n1. 下载安装MPICH,点击[下载](https://www.mpich.org/downloads/)。这里下载的是微软官方的MPI工具，打开后有两个工具包，都要下载安装，前后顺序无要求。\n\n   {% asset_img 1.jpg 500 500  %}\n\n   {% asset_img 2.jpg 500 500 %}\n\n2. 安装。\n\n   点击.exe文件，建议安装到C盘默认路径；\n   点击.msi文件，建议安装到C盘默认路径；\n\n   打开cmd命令，输入`set MSMPI`\n\n3. 配置visual studio\n\n   第一步：\n\n   - 创建新项目或者打开您现有的项目。\n   - 打开属性页面，选择Debug或Release的X64模式。\n\n   第二步：\n\n   - VC++目录→ 包含目录 追加 `你的路径\\Microsoft SDKs\\MPI\\Include`。\n   - VC++目录→ 库目录 追加 `你的路径\\Microsoft SDKs\\MPI\\Lib\\x64。`\n\n   第三步：\n\n   - 设置附加包含目录 `$(MSMPI_INC);$(MSMPI_INC)\\x64。`\n   - C/C++ → 预处理器 → 预处理定义 末尾追加 `;MPICH_SKIP_MPICXX。`\n   - C/C++ → 代码生成 → 运行库 选择 `多线程调试/MTd`或者`多线程/MT。`\n\n   第四步：\n\n   - 链接器→输入→附加依赖项 追加 `;msmpi.lib。`\n\n   - 链接器→所有选项→附加库目录 `$(MSMPI_LIB64)。`\n\n     **最后点击确定就OK了！**\n\n4. 编译&运行测试\n\n   编译后运行程序，需要注意的是，MPI程序不能直接运行，否则只会识别一个处理器。\n\n   **正确的指令**是：`mpiexec.exe -n your_processor_number your_code_name`\n\n   运行示范程序如下:\n\n   ```c++\n   #include <mpi.h>\n   #include <stdio.h>\n   \n   int main(int argc, char** argv) {\n       // 初始化 MPI 环境\n       MPI_Init(NULL, NULL);\n   \n       // 通过调用以下方法来得到所有可以工作的进程数量\n       int world_size;\n       MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n   \n       // 得到当前进程的秩\n       int world_rank;\n       MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n   \n       // 得到当前进程的名字\n       char processor_name[MPI_MAX_PROCESSOR_NAME];\n       int name_len;\n       MPI_Get_processor_name(processor_name, &name_len);\n   \n       // 打印一条带有当前进程名字，秩以及\n       // 整个 communicator 的大小的 hello world 消息。\n       printf(\"Hello world from processor %s, rank %d out of %d processors\\n\",\n           processor_name, world_rank, world_size);\n   \n       // 释放 MPI 的一些资源\n       MPI_Finalize();\n   }\n   ```\n\n   成功，Enjoy!\n\n{% asset_img 3.jpg 500 500 %}\n\n## Linux\n\n*以下实例为Ubuntu20.04.4 LTS + gcc 4.7.5*\n\nUbuntu下安装MPICH较为简单，使用apt安装即可。\n\n> MPICH是一种最重要的MPI实现它可以免费从http://www.unix.mcs.anl.gov/mpi/mpich取得 更为重要的是 MPICH是一个与MPI规范同步发展的版本 每当MPI推出新的版本就会有相应的MPICH的实现版本 目前MPICH的最新版本是MPICH-4.0.2，具体请参看MPICH官网：www.mpich.org\n\n1. 安装。直接使用以下命令：\n\n   ```bash\n   sudo apt-get update\n   ```\n\n   ```bash\n   sudo apt-get -y install mpich\n   ```\n\n2. 编译与运行：\n\n   ```bash\n   mpicc -o your_code_name your_cpp_name\n   ```\n\n   ```bash\n   mpirun -n your_processor_number ./your_code_name\n   ```\n\n成功，如下图所示，enjoy!\n\n{% asset_img 4.jpg 500 500 %}\n","tags":["MPI"],"categories":["并行计算"]},{"title":"如何安装win11+ubuntu双系统","url":"/Mrluo123.http-github.io/post/3709.html","content":"\n# Windows11/10安装Ubuntu 20.04.6 LTS双系统\n<!-- more -->\n**1）如果你电脑本来就是双系统，打算重装ubuntu，则需要完全卸载ubuntu并删除引导项，请参考[这篇文章](https://blog.csdn.net/qq_43310597/article/details/105782722)：**\n\n**tips:推荐使用[diskgenius](https://www.diskgenius.cn/download.php)来完全删除ubuntu，最简单最方便**\n\n\n\n**2）如果你电脑只有win系统，打算安装ubuntu作为双系统，请参考youtube这个视频教程：**\n\n<iframe width=\"760\" height=\"427\" src=\"https://www.youtube.com/embed/bVmTxwUuXlM\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n\n\n\n\n\n\n","tags":["Ubuntu","双系统"],"categories":["Ubuntu"]},{"title":"使用OpenMP进行C++并行编程的一些心得","url":"/Mrluo123.http-github.io/post/11326.html","content":"\n最近在编程时，由于涉及到大量for循环等遍历计算，需要了解并行编程知识，于是看了下OpenMP的相关教程；\n<!-- more -->\n> OpenMP是由OpenMP Architecture Review Board牵头提出的，并已被广泛接受，用于[共享内存](https://baike.baidu.com/item/共享内存/2182364)并行系统的多处理器程序设计的一套指导性编译处理方案(Compiler Directive) [1] 。OpenMP支持的编程语言包括[C](https://baike.baidu.com/item/C)、[C++](https://baike.baidu.com/item/C%2B%2B)和[Fortran](https://baike.baidu.com/item/Fortran)；而支持OpenMp的[编译器](https://baike.baidu.com/item/编译器/8853067)包括Sun Compiler，GNU Compiler和Intel Compiler等。OpenMp提供了对[并行算法](https://baike.baidu.com/item/并行算法/967188)的高层的抽象描述，程序员通过在[源代码](https://baike.baidu.com/item/源代码)中加入专用的pragma来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为通常的程序(一般为[串行](https://baike.baidu.com/item/串行/3555818))，代码仍然可以正常运作，只是不能利用多线程来加速程序执行。\n\n在用OpenMP进行并行编程时，只需要加入#pragma omp parallel语句以及后面的操作命令即可，十分简单，便于程序员操作；\n\n下面以vs为例，介绍OpenMP的简单用法：\n\n1、首先，新建项目并添加代码后，需要打开vs的OpenMP支持选项：**右键项目属性-C/C+±语言-OpenMP支持**\n{% asset_img 1.jpg 500 500 %}\n**2、其次，需要添加头文件<omp.h>**\n\n3、OpenMP有很多命令可以用，比较常见的就是用于for循环来提升循环效率，即`#pragma  omp parallel for`\n\n4、**在使用OpenMP时，要注意避免线程数据之间的竞争而导致计算出现差错，同时，亦应合理管理私有数据和公有数据**\n\n为避免线程数据之间的竞争而导致计算出现差错，下面是应用的一个例子\n\n```CPP\n#include \"pch.h\"\n#include <iostream>\n#include <stdio.h>\n#include \"omp.h\"\n#include<ctime>\nusing namespace std;\nint main(int argc, char **argv) {\n\t//设置线程数，一般设置的线程数不超过CPU核心数，这里开4个线程执行并行代码段\n\tomp_set_num_threads(8);\n\tdouble start = clock();\n\tint sum=0;\n#pragma omp parallel \n\t{\n\t#pragma omp for reduction(+:sum)\n\t\tfor (int i = 0; i < 40000; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 40000; j++)\n\t\t\t{\n\t\t\t\t//cout << \"i = \" << i << \", I am Thread \" << omp_get_thread_num() << endl;\n\t\t\t\tsum += 1;\n\t\t\t}\n\t\t}\t\n\t}\n\tprintf(\"sum=%d\\n\", sum);\n\tdouble end = clock();\n\tprintf(\"Running time= %f\", (end - start)/CLOCKS_PER_SEC);\n}\n```\n\nreduction(+:sum)\n\n冒号前面的“+”表示在各线程中sum要保留数据，计算结束后一起累加。\n\n当然，OpenMP 不止能做累加，凡是累计运算都是可以的，如下表所示：\n\n| 操作 | 私有临时变量初值 |\n| ---- | ---------------- |\n| +、- | 0                |\n| *    | 1                |\n| &    | ~0               |\n| `|`  | 0                |\n| ^    | 0                |\n| &&   | 1(true)          |\n| `||` | 0(false          |\n\n再如，为合理管理私有数据和公有数据，private命令可以声明循环的私有变量，这些变量在各线程中互相独立，互不影响，但是要注意，private不可声明static变量；\n\n```CPP\n#pragma  omp parallel for private(k1,k2)\n\t\tfor (k1 = 1; k1 < 100; k1++)\n\t\t{\n\t\t\tfor (k2 = 1; k2 < 100; k2++)\n\t\t\t{\n\t\t\t\tcout <<\"k1=\"<< k1 << endl;\n\t\t\t\tcout <<\"k2=\"<< k2 << endl;\n\t\t\t\tcout << \"k=\" << k << endl;\n\t\t\t}\n\t\t\t\n\t\t}\n```\n\n","tags":["C++","OpenMP"],"categories":["并行计算"]},{"title":"关于C++函数引用传递的一些心得","url":"/Mrluo123.http-github.io/post/621.html","content":"\n最近在看别人的程序的时候，了解到一种新的函数写法。\n通常，我么在使用通常来讲，函数通过形参接收实参的数值，并返回相应的结果，这种方式我么成为“***按值传递***”（pass-by-value）,这种传递方法并不会修改原始数值本身。\n<!-- more -->\n***但是，如果想直接更改正在被调用中的函数中的一个值，就可以通过引用传递的方式来进行实现。***\n这种方法我们称之为“***引用传递***”(pass-by-reference)\n　引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。（此处引用*飘剑如虹 *的博客，原地址https://blog.csdn.net/u013130743/article/details/80806179）\n\n### 什么叫引用传递？\n\n当使用引用变量作为形参时，它将变为实参列表中相应变量的别名，对形参进行的任何更改都将真正更改正在调用它的函数中的变量。当以这种方式将数据传递给形参时，该实参被称为按引用传递。\n为了指明一个函数的形参是按引用传递的，只需要简单的对函数原型的形参类型添加一个&标识即可\n例如：\n\n```CPP\nint &a//这里的a就表示一个int类型的引用\n```\n\n为了让大家更清楚的认识到引用传递，这里举个例子：\n\n```CPP\nusing namespace std;\nint add1(int a, int b)\n{\n\tint c = a + b;\n\treturn c;\n}//按值引用\nint a = 1;\nvoid square(int &a)\n{\n\ta = pow(a, 2);\n}//引用传递\nint main()\n{\n    \n\n\tcout <<\"1和2加起来等于 \"<< add1(1, 2) << endl;\n\tint z = 2;\n\tcout << \"before reference 'z'= \" << z << endl;\n\tsquare(z);\n\tcout << \"after reference 'z'= \" <<z<< endl;\n}\n```\n\n输出：\n{% asset_img 1.jpg 500 500  %}\n","tags":["引用传递"],"categories":["C++"]},{"title":"虚拟机安装Debian以及配置SALOME教程","url":"/Mrluo123.http-github.io/post/23422.html","content":"\ndate: 2021-12-05 20:35:00\n---\n\n本文为Linux系统Debian8.0的安装以及开源多物理场耦合平台SALOME的配置教程。\n<!-- more -->\n### 一、准备文件\n\n```html\n1. 虚拟机使用VirtualBox--版本5.2，不建议使用最新版本\n   下载链接：[VirtualBox官方中文版5.2.26](http://www.xitongtiandi.net/soft_gj/4907.html)\n2. Debian使用8.0即可，使用新版本需要对应版本的SALOME；\n   下载链接可以直接去官网下载:[SALOME官网](https://www.salome-platform.org/)\n3. SALOME直接去官网下载，目前使用SALOME9.2版本，仅用于后处理。倘若要使用SALOME的YACS模块，则要使用SALOME8.4版本\n```\n\n### 二 、Debian安装\n\n请参考[VirtualBox安装Debian教程](https://blog.csdn.net/technologyleader/article/details/81870496)\n\n### 三 、安装增强功能以及共享文件夹\n\n - 进入Debian系统内，在VirtualBox的菜单栏上，点击Devices- Insert Guest Additions CD image。       \n   这样操作不会提示什么信息，但是可以看到下图中光盘。\n\n\n{% asset_img 1.jpg 500 500 %}\n\n\n\n -  在命令号窗口里，安装linux-headers-3.16.0-4-amd64、gcc和 make。在root用户下，输入命令：`apt-get install linux-headers-3.16.0-4-amd64 gcc make`\n -  在home工作目录下，输入命令ls，查看是否有mnt/文件夹 \n -  进入mnt文件夹里，输入命令`cd mnt`。创建新的文件夹cdrom，输入命令`mkdir cdrom`。\n -  回到上一级目录里，输入命令`cd ..`。将cd驱动器安装在新建的文件夹里，输入命令`mount /dev/cdrom /mnt/cdrom`。\n -  输入命令`cd mnt/cdrom`。 输入命令ls，查看在cdrom里的所有文件。\n -  运行VBoxLinuxAdditions.run。输入命令`./ VBoxLinuxAdditions.run`. 如果有选项，选择yes. 这个操作的之下需要几分钟。这样VirtualBox增强功能就安装好了。现在输入命令shutdown now关闭虚拟机。\n    {% asset_img 2.jpg 500 500 %}\n -  在Virtualbox 主面板上，选中刚才的系统名字，例如下图中的kanglong。点击Setting-General-Advanced. 修改Shared Clipboard和Drag’n’Drop的设置为Bidirectional. 点击OK. 这将允许在两个系统之间复制文本。\n    {% asset_img 3.jpg 500 500 %}\n\n### 四、SALOME安装\n\n1.  首先需将SALOME安装包放到windows共享文件夹下面\n    {% asset_img 4.jpg 500 500 %}\n2.  然后进入虚拟机系统，创建一个文件夹，并将共享文件夹挂载到该文件夹：\n    依次 输入命令如下：\n\n```cpp\nsu//进入root用户\nmkdir luoxiaoshare//创建文件\nmount  -t  vboxsf  VMshares luoxiaoshare//VMshares即win下的共享文件夹\n```\n\n挂载成功，可以在luoxiaoshare下看到共享文件夹的内容：\n{% asset_img 5.jpg 500 500  %}\n然后将SALOME安装包复制到linux某一文件夹，使用命令\n\n```cpp\nmkdir /home/luoxiao/salome9.2          //可以自行设置，放在哪里都可以\ncp -i SALOME-9.2.0-DB08-SRC.tgz /home/luoxiao/salome9.2/  //复制安装包\nmkdir SALOMEfiles //准备解压文件夹\ntar zxvf SALOME-9.2.0-DB08-SRC.tgz  -C SALOMEfiles/   //解压后放在该文件夹下\ncd SALOMEfiles/\ncd SALOME-9.2.0-DB08-SRC\n./salome   //可直接运行salome,无需安装\n\n```\n\n{% asset_img 6.jpg 500 500 %}\n\n{% asset_img 7.jpg 500 500 %}\n\n### **运行成功，enjoy！**\n","tags":["Linux","SALOME","虚拟机"],"categories":["Ubuntu"]},{"title":"一个例子告诉你C++引用和指针的区别","url":"/Mrluo123.http-github.io/post/36765.html","content":"\n#### C++引用vs指针\n\n引用很容易和指针混淆，他们之间有三个主要的不同：\n\n- 不存在空引用。引用必须连接到一块合法的内存。\n- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n- 引用必须在创建时被初始化。指针可以在任何时间被初始化。\n<!-- more -->\n例如：\n\n```cpp\nint i=0;\nint& r=i;\ndouble &s=d\n```\n\n第一个声明可以读作“r是一个初始化为i的整型引用”，\n\n第二个声明可以读作：“s是一个初始化为d的double型引用”\n\n此外，通过一个例子就可以发现：\n\n引用者的内容和内存都和被引用者保持一致。而赋值的话不是这样，只是内容相等，会另开辟一个内存地址来存储。\n\n```cpp\n#include\"pch.h\"//预编译头文件一定要放在最后面\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tint a = 1;\n\tfloat b = 1.234;\n\tint& c = a;\n\tint c1 = a;\n\tfloat& d = b;\n\tstd::cout << \"c的值等于\" << c << std::endl;\n\tstd::cout << \"a的内存地址为\" << &a << std::endl;//&为取地址符\n\tstd::cout << \"c的内存地址为\" << &c << std::endl;\n\tstd::cout << \"c1的内存地址为\" << &c1<< std::endl;\n\tstd::cout << \"d的值等于\" << d << std::endl;\n\treturn 0;\n}\n```\n\n结果：\n\n c的值等于1\n​ a的内存地址为0104FC38\n​ c的内存地址为0104FC38\n​ c1的内存地址为0104FC14\n​ d的值等于1.234\n","tags":["C++"],"categories":["C++"]},{"title":"C++用流函数进行格式化输出","url":"/Mrluo123.http-github.io/post/3482.html","content":"\n\n调试的时候，输出友好的话，可以有效的提高调试的效率，因此，在这里整理一下，一些格式化输出的常见方法。\n\n<!-- more -->\n\n\n\n# 1、setf\n\nstef是set flags(设置标志)的缩写。编制（flags)是以二选一的方式来做一件事情的指令。\n\n1. ios::fixed 不用e计数法来表示浮点数\n\n2. ios::scientific 用e计数法来表示浮点数\n\n3. ios::showpos 始终以浮点数显示小数点和尾随的0。如果不设置此表示，而且一个数字在小数点后全是0，那么他在输出时可能既没有小数点，也没有尾随的0。\n\n4. ios::right 在使用成员函数width()来设置域宽值后，输出的时候会按照区域宽度来右对齐输出\n\n5. ios::left 在使用成员函数width()来设置域宽值后，输出的时候会按照区域宽度来左对齐输出\n\n   例子：\n\n```c++\n#include \"pch.h\"\n#include <iostream>\n#include<fstream>\n#include<cstdlib>\nusing namespace std;\nint main()\n{\n\tfloat a = 0.00;\n\tfloat b = 1234567.23;\n\tint c = 10;\n\tcout.width(50);     //设置输出域宽为50\n\tcout << \"Peter is a hansome man\" << endl;\n\tcout.setf(ios::showpoint);   //显示小数点后面位数\n\tcout << a << endl;\n\tcout.unsetf(ios::showpoint);//取消上一个格式化输出\n\tcout.setf(ios::scientific);//科学计数法输出浮点数\n\tcout << b << endl;\n\tcout.unsetf(ios::scientific);//取消上一个格式化输出\n\tcout.setf(ios::fixed);//直接输出浮点数\n\tcout << b << endl;\n\tcout.unsetf(ios::fixed);//取消上一个格式化输出\n\tcout.setf(ios::left);//靠左输出\n\tcout << b << \"\t\"<< c << endl;\n}\n```\n\n\n\n# 2、setw\n\n操纵元函数setw()和width()类似：\n\n```c++\ncout<< “strat” << setw(4) << 10;\n```\n\n输出： 10；在10前面有两个空格，因为是4个域宽输出的。\n\n## 3、setprecision\n\n使用*setprecision*(n)可控制输出流显示浮点数的数字个数:\n\n```c++\ncout<< setprecision(2) << 10.4<< endl;\n```\n\n输出：10.30\n","tags":["格式化输出"],"categories":["C++"]}]